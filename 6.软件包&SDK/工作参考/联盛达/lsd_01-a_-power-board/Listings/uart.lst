C51 COMPILER V9.54   UART                                                                  07/23/2024 15:06:20 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE scr\uart.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inc;.\USER) DEBUG OBJ
                    -ECTEXTEND PRINT(.\Listings\uart.lst) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          
   3          //16MHZ 娉㈢圭179600
   4          #define d_S0RELH    0x03
   5          #define d_S0RELL    0xCC    
   6          
   7          
   8          
   9          #if(CRC16_ENABLE)
  10          
  11          //#define TX_7(P1) SEND_DATA((P1)&0xFF)                    //锟斤拷锟酵碉拷锟斤拷锟街斤拷
  12          //#define TX_7N(P,N) SendNU8((uint8 *)P,N)                 //锟斤拷锟斤拷N锟斤拷锟街斤拷
  13          //#define TX_15(P1) TX_8((P1)>>8);TX_8(P1)                 //锟斤拷锟斤拷16位锟斤拷锟斤拷
  14          //#define TX_15N(P,N) SendNU16((uint16 *)P,N)              //锟斤拷锟斤拷N锟斤拷16位锟斤拷锟斤拷
  15          //#define TX_31(P1) TX_16((P1)>>16);TX_16((P1)&0xFFFF)     //锟斤拷锟斤拷32位锟斤拷锟斤拷
  16          
  17          
  18          static uint16 _crc16 = 0xffff;
  19          /*! 
  20          *  \brief  检查数据是否符合CRC16校验
  21          *  \param buffer 待校验的数据
  22          *  \param n 数据长度，包含CRC16
  23          *  \param pcrc 校验码
  24          */
  25          static void AddCRC16(uint8 *buffer,uint16 n,uint16 *pcrc)
  26          {
  27   1          uint16 i,j,carry_flag,a;
  28   1      
  29   1          for (i=0; i<n; i++)
  30   1          {
  31   2              *pcrc=*pcrc^buffer[i];
  32   2              for (j=0; j<8; j++)
  33   2              {
  34   3                  a=*pcrc;
  35   3                  carry_flag=a&0x0001;
  36   3                  *pcrc=*pcrc>>1;
  37   3                  if (carry_flag==1)
  38   3                      *pcrc=*pcrc^0xa001;
  39   3              }
  40   2          }
  41   1      }
  42          /*! 
  43          *  \brief  检查数据是否符合CRC16校验
  44          *  \param buffer 待校验的数据，末尾存储CRC16
  45          *  \param n 数据长度，包含CRC16
  46          *  \return 校验通过返回1，否则返回0
  47          */
  48          uint16 CheckCRC16(uint8 *buffer,uint16 n)
  49          {
  50   1          uint16 crc0 = 0x0;
  51   1          uint16 crc1 = 0xffff;
  52   1      
  53   1          if(n>=2)
  54   1          {
C51 COMPILER V9.54   UART                                                                  07/23/2024 15:06:20 PAGE 2   

  55   2              crc0 = ((buffer[n-2]<<8)|buffer[n-1]);
  56   2              AddCRC16(buffer,n-2,&crc1);
  57   2          }
  58   1      
  59   1          return (crc0==crc1);
  60   1      }
  61          /*! 
  62          *  \brief  发送一个字节
  63          *  \param  c 
  64          */
  65          void SEND_DATA(uint8 c)
  66          {
  67   1          AddCRC16(&c,1,&_crc16);
  68   1          SendChar(c);
  69   1      }
  70          /*! 
  71          *  \brief  帧头
  72          */
  73          void BEGIN_CMD()
  74          {
  75   1          TX_8(0XEE);
  76   1          _crc16 = 0XFFFF;                      //开始计算CRC16
  77   1      }
  78          /*! 
  79          *  \brief  帧尾
  80          */
  81          void END_CMD()
  82          {
  83   1          uint16 crc16 = _crc16;
  84   1          TX_16(crc16);                         //发送CRC16
  85   1          TX_32(0XFFFCFFFF);
  86   1      }
  87          
  88          #else
              
              #define SEND_DATA(P) SendChar(P)          //锟斤拷锟斤拷一锟斤拷锟街斤拷
              #define BEGIN_CMD() TX_8(0XEE)            //帧头
              #define END_CMD() TX_32(0XFFFCFFFF)       //帧尾
              
              #endif
  95          
  96          
  97          
  98          bit bU0TX =0;
  99          u16 cmd_pos =0;
 100          u32 cmd_state=0;
 101          
 102          void Uart_Init(void)
 103          {
 104   1          S0RELH   = d_S0RELH;
 105   1          S0RELL   = d_S0RELL;
 106   1          AUX     |= 0x80;            // BRS = 1
 107   1          PCON    |= 0x80;            // SMOD =1
 108   1          IEN0    |= 0x90;            // EA=1, ES0=1, interrupt enable
 109   1          S0CON    = 0x50;            // mode 1, SM20=0, Revice enable
 110   1          TI       = 0;
 111   1      }
 112          
 113          void UART0_ISR(void) interrupt d_UART0_Vector
 114          {
 115   1          unsigned char RXBUF0;
 116   1          if (RI)                     // INT_RX
C51 COMPILER V9.54   UART                                                                  07/23/2024 15:06:20 PAGE 3   

 117   1          {
 118   2              RI = 0;                 // RI clear
 119   2              RXBUF0 = S0BUF;         // Read BUF, user code...
 120   2              PushQueue(&LoopUart,RXBUF0);
 121   2          }
 122   1          else                        // INT_TX
 123   1          {
 124   2              bU0TX  = 0;
 125   2              TI     = 0;             // TI clear
 126   2          }
 127   1      }
 128          void SendChar(unsigned char n_temp0)
 129          {
 130   1          bU0TX = 1;
 131   1          S0BUF = n_temp0;
 132   1          while(bU0TX)
 133   1          {
 134   2              ;
 135   2          }
 136   1      }
 137          
 138          
 139          void QueueInit(LoopUartType *uart)
 140          {
 141   1          u8 i;
 142   1          uart->rear = uart->front =0;
 143   1              cmd_pos=0;
 144   1              cmd_state=0;
 145   1          for(i=0;i<RX_BUFF_SIZE;i++)
 146   1              uart->rx_buf[i]=0;
 147   1              
 148   1      }
 149          
 150          // ょ┖
 151          bit ISEmpty(const LoopUartType *uart)
 152          {
 153   1          return uart->rear == uart->front;
 154   1      }
 155          
 156          //ゆ弧
 157          bit ISFull(const LoopUartType *uart)
 158          {
 159   1          return (uart->rear + 1)%RX_BUFF_SIZE == uart->front;
 160   1      }
 161          
 162          //ラ
 163          uartStateType PushQueue(LoopUartType *uart,u8 Data)
 164          {
 165   1          if(ISFull(uart)) 
 166   1              return UartFull;
 167   1          uart->rx_buf[uart->rear] = Data;
 168   1          uart->rear = (uart->rear+1)%RX_BUFF_SIZE;
 169   1          return UartOk;
 170   1      }
 171          
 172          //洪
 173          uartStateType PopQueue(LoopUartType *uart,u8 *Data)
 174          {
 175   1          if(ISEmpty(uart))
 176   1              return UartEmpty;
 177   1          *Data= uart->rx_buf[uart->front];
 178   1          uart->front = (uart->front+1)%RX_BUFF_SIZE;
C51 COMPILER V9.54   UART                                                                  07/23/2024 15:06:20 PAGE 4   

 179   1          return UartOk;
 180   1      }
 181          
 182          u8 SizeQueue(const LoopUartType *uart)
 183          {
 184   1          return ((uart->rear+RX_BUFF_SIZE-uart->front)%RX_BUFF_SIZE);
 185   1      }
 186          
 187          
 188          u16 QueueFinDataFrame(LoopUartType *uart,u8 *buffer)
 189          {
 190   1              u16 cmd_size =0;
 191   1          u8 _data =0;
 192   1          while(SizeQueue(uart)>0)
 193   1          {
 194   2              PopQueue(uart,&_data);
 195   2              if((cmd_pos==0)&&(_data != CMD_HEAD))
 196   2                  continue;
 197   2              if(cmd_pos < RX_BUFF_SIZE)
 198   2                  buffer[cmd_pos++] = _data;
 199   2              cmd_state= ((cmd_state<<8)|_data);
 200   2              if(cmd_state == CMD_TAIL)               
 201   2                      {
 202   3                              cmd_size=cmd_pos;
 203   3                              cmd_state=0;
 204   3                              cmd_pos=0;
 205   3      #if(CRC16_ENABLE)
 206   3                  //去掉指令头尾EE，尾FFFCFFFF共计5个字节，只计算数据部分CRC
 207   3                  if(!CheckCRC16(buffer+1,cmd_size-5))                      //CRC校验
 208   3                      return 0;
 209   3      
 210   3                  cmd_size -= 2;                                            //去掉CRC16（2字节）
 211   3      #endif
 212   3                  return cmd_size;
 213   3                      }
 214   2          }
 215   1          return 0;
 216   1      }
 217          
 218          
 219          //注意数据不能出现帧尾0xFFFCFFFF
 220          void DataFrameTransmission(const void *Data,u8 cmd,u8 len)
 221          {
 222   1          u8 i=0;
 223   1          BEGIN_CMD();
 224   1          SEND_DATA(cmd);
 225   1          SEND_DATA(len);
 226   1          for(i=0;i<len;i++)
 227   1              SEND_DATA(((u8*)Data)[i]);
 228   1          END_CMD();
 229   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1373    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8      51
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.54   UART                                                                  07/23/2024 15:06:20 PAGE 5   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
