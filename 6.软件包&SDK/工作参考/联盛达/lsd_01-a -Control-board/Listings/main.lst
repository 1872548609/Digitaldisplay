C51 COMPILER V9.54   MAIN                                                                  07/12/2025 08:10:58 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keilC51\C51\BIN\C51.EXE USER\main.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\inc;.\USER) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          
   3          DutyCycleOutputType xdata    PumpCtrl            ={0};  
   4          DutyCycleOutputType xdata    PotHeatCtrl         ={0};  
   5          DirectOutputType    xdata    DirectOutput        ={0};
   6          FlowCtrlTypedef     xdata    FlowCtrl            ={0};
   7          DeviceStatusTypedef xdata    DeviceStatus        ={0};
   8          AdParaTypedef       xdata    AdPara              ={0};
   9          LampCtrlTypedef   xdata   LampCtrl       ={0};
  10          volatile LoopUartType xdata  LoopUart            ={0};
  11          
  12          
  13          u8 *CurSettingTemp      = &TempSingleEsp ; //ÂΩìÂâçËÆæÂÆöÊ∏©Â∫¶
  14          u8 xdata cmd_buffer[64]={0};
  15          u8 xdata curTempUnit      = CentigradeDis;//ÂΩìÂâçÊ∏©Â∫¶Âçï‰Ωç
  16          u8 xdata MakeFlow         = 0; //Â∑•‰ΩúÊµÅÈáè
  17          u8 xdata ErrCode          = 0; //ÈîôËØØ‰ª£Á†Å
  18          u8 xdata UartFlag         = 0; //‰∏≤Âè£Êé•Êî∂Ê†áÂøó
  19          u8 xdata CurPotAimTemp    = 90; //ÂΩìÂâçÁÖ≤ÁõÆÊ†áÊ∏©Â∫¶
  20          u8 xdata TempSingleEsp    = 0; //ÂçïÊùØÊÑèÂºèÊ∏©Â∫¶
  21          u8 xdata TempDoubleEsp    = 0; //ÂèåÊùØÊÑèÂºèÊ∏©Â∫¶
  22          u8 xdata TempCoffee       = 0; //ÂíñÂï°Ê∏©Â∫¶ 
  23          u8 xdata TempAmericano    = 0; //ÁæéÂºè
  24          u8 xdata TempColdDrink    = 30; //ÂÜ∑È•ÆÊ∏©Â∫¶
  25          u8 xdata CurFuntion       = 0; //ÂΩìÂâçÂäüËÉΩ
  26          u8 xdata GrindTime        = 10; //Á£®Ë±ÜÊó∂Èó¥
  27          u8 xdata PreInjectionTime = 0; //È¢ÑÊ≥®Ê∞¥Êó∂Èó¥
  28          u8 xdata EndDis           = 0; //ÁªìÊùüÊòæÁ§∫
  29          u8 xdata EndDisCnt        = 0; //ÁªìÊùüÊòæÁ§∫ËÆ°Êï∞
  30          u16 xdata CurFlow         = 0; //ÂΩìÂâçÊµÅÈáè
  31          u16 xdata ProcessTime     = 0;
  32          u16 xdata TotalFlow       = 0;
  33          u32 xdata SleepCut        = 0; //‰ºëÁú†ËÆ°Êï∞   
  34          
  35          //ËäØÁâáÂàùÂßãÂåñ
  36          void MCU_init(void)
  37          {
  38   1          Gpio_init();
  39   1          Uart_Init();
  40   1          LVI_EN();//Êï∞ÊçÆÂ≠òÂÇ®
  41   1          PWM_initialize();
  42   1          TIMER0_initialize();
  43   1          QueueInit(&LoopUart);
  44   1          EA  =1;
  45   1      }
  46          
  47          void ProcessMessage(PCTRL_MSG msg)
  48          {
  49   1          u8 cmdType = msg->cmd_type;
  50   1          u8 len     = msg->cmd_len;
  51   1          switch (cmdType)
  52   1          {
  53   2          case CMD_SteamHeat:
  54   2          UartFlag &= ~CMD_SteamHeat;
C51 COMPILER V9.54   MAIN                                                                  07/12/2025 08:10:58 PAGE 2   

  55   2      
  56   2              break;
  57   2          case CMD_SteamPump:
  58   2          UartFlag &= ~CMD_SteamPump;
  59   2      
  60   2              break;
  61   2          case CMD_DirOutput:
  62   2          UartFlag &= ~CMD_DirOutput;
  63   2      
  64   2              break;
  65   2          case CMD_ADSensor:
  66   2          UartFlag &= ~CMD_ADSensor;
  67   2          memcpy(&AdPara,msg->param,sizeof(AdParaTypedef));
  68   2      
  69   2          break;
  70   2          case CMD_LampCtrl:
  71   2          UartFlag &= ~CMD_LampCtrl;
  72   2          
  73   2              break;
  74   2          case CMD_Flow:
  75   2          UartFlag &= ~CMD_Flow;
  76   2          memcpy(&CurFlow,msg->param,sizeof(CurFlow));
  77   2      
  78   2              break;
  79   2      
  80   2          case CMD_FlowCtrl:
  81   2          UartFlag &= ~CMD_FlowCtrl;
  82   2          
  83   2              break;
  84   2          default:
  85   2              break;
  86   2          }
  87   1      }
  88          
  89          void FlowCheck()
  90          {
  91   1         static u8 FlowFlushCnt = 0;
  92   1         static u16 NoFlowCnt = 0;
  93   1         static u16 Preflow = 0;
  94   1         if(FlowCtrl.FlowCtrlByte == Flow_Scan)
  95   1         {
  96   2              FlashUartByte(CMD_Flow);
  97   2              if((CurFlow - Preflow) < 2)
  98   2              {
  99   3                  NoFlowCnt++;
 100   3                  if(NoFlowCnt >= Delay_10s)
 101   3                  {
 102   4                          ErrCode     |= ErrTankLack;
 103   4                      //    DeviceStatus = status_Err;  
 104   4                          if(LT.MakeCoffeTask.Logictrl.LogictrlBit.execute)LT.MakeCoffeTask.Logictrl.LogictrlBit
             -.quit= 1;
 105   4                          if(LT.MakeSteamTask.Logictrl.LogictrlBit.execute)LT.MakeSteamTask.Logictrl.LogictrlBit
             -.quit= 1;
 106   4                          if(LT.MakeHotWaterTask.Logictrl.LogictrlBit.execute)LT.MakeHotWaterTask.Logictrl.Logic
             -trlBit.quit= 1;
 107   4                          if(LT.PipelineFlushingTask.Logictrl.LogictrlBit.execute)LT.PipelineFlushingTask.Logict
             -rl.LogictrlBit.quit= 1;
 108   4                          DeviceStatus = status_Idle;
 109   4                  }
 110   3              }
 111   2          else 
 112   2              {
C51 COMPILER V9.54   MAIN                                                                  07/12/2025 08:10:58 PAGE 3   

 113   3                  ErrCode &= (~ErrTankLack);
 114   3            NoFlowCnt=0;
 115   3              }
 116   2             FlowFlushCnt++;
 117   2             if (FlowFlushCnt>= Delay_1S)
 118   2             {
 119   3                 FlowFlushCnt= 0;
 120   3                 Preflow = CurFlow;
 121   3             }
 122   2         }
 123   1         else
 124   1         {
 125   2            if((UartFlag&CMD_Flow)==0)
 126   2          {
 127   3            TotalFlow += CurFlow;
 128   3                  if(TotalFlow >= CleanFlow)
 129   3                      ErrCode |= Descaling;
 130   3            CurFlow = 0;
 131   3            Preflow = 0;
 132   3            NoFlowCnt=0;
 133   3          }
 134   2         }
 135   1         if((DeviceStatus > status_Down)&&(DeviceStatus < status_Err))
 136   1         {
 137   2              Dis_Error(ErrCode); //ÈúÄË¶ÅÊ∏ÖÊ¥Å
 138   2              Dis_Pressure(AdPara.Press,1); //ÊòæÁ§∫ÂéãÂäõ
 139   2         }
 140   1      }
 141          
 142          
 143          void mainTask()//‰∏ªÁä∂ÊÄÅ
 144          {
 145   1          switch (DeviceStatus)
 146   1          {
 147   2          //=====================================================================// 1
 148   2          case status_Init://ÂàùÂßãÂåñÔºåÂÆåÊàêÂêéËá™Âä®ËøõÂÖ•ÂÖ≥Èó≠Áä∂ÊÄÅ
 149   2          LT.InitTask.Logictrl.LogictrlBit.execute = 1;//ÊâßË°åÂàùÂßãÂåñ‰ªªÂä°//Êé•ÈÄöÁîµÊ∫êÔºåÊú∫Âô®ÈïøÂìç‰∏ÄÂ£∞(
             -Êª¥1s)ÔºåÊâÄÊúâÁÅØÂèäÊòæÁ§∫ÂÖ®‰∫Æ1sÂêéÁÜÑÁÅ≠Ôºõ‰ªÖ‚ÄúÁîµÊ∫ê‚ÄùÊåâÈîÆÁÅØÈó™ÁÉÅÔºàÈó¥Èöî1s/Èó™Ôºâ„ÄÇ
 150   2          break;
 151   2          //=====================================================================// 2
 152   2          case status_Down://ÂÖ≥Êú∫Ôºå‰ªÖ‚ÄúÁîµÊ∫ê‚ÄùÊåâÈîÆÁÅØÈó™ÁÉÅÔºàÈó¥Èöî1s/Èó™Ôºâ„ÄÇ
 153   2          ProcessTime++;
 154   2          if(ProcessTime < Delay_1S)//‰∏ÄÁßí
 155   2            Dis_PilotLamp(Led_Power);//ÊòæÁ§∫ÁîµÊ∫êÁÅØÈó™ÁÉÅ
 156   2          else if(ProcessTime < (2*Delay_1S))//‰∏§Áßí
 157   2            Dis_PilotLamp(0);//ÁîµÊ∫êÁÅØÂÖ≥Èó≠
 158   2          else//‰∏âÁßíÂÖ≥Èó≠ÊâÄÊúâ‰ªªÂä°
 159   2             ProcessTime =0; 
 160   2          if(LT.CleanTask.Logictrl.LogictrlBit.execute)LT.CleanTask.Logictrl.LogictrlBit.quit= 1;
 161   2          if(LT.GrindBeanTask.Logictrl.LogictrlBit.execute)LT.GrindBeanTask.Logictrl.LogictrlBit.quit= 1;
 162   2          if(LT.MakeCoffeTask.Logictrl.LogictrlBit.execute)LT.MakeCoffeTask.Logictrl.LogictrlBit.quit= 1;
 163   2          if(LT.MakeSteamTask.Logictrl.LogictrlBit.execute)LT.MakeSteamTask.Logictrl.LogictrlBit.quit= 1;
 164   2          if(LT.PotHeatTask.Logictrl.LogictrlBit.execute)LT.PotHeatTask.Logictrl.LogictrlBit.quit= 1;
 165   2          if(LT.MakeHotWaterTask.Logictrl.LogictrlBit.execute)LT.MakeHotWaterTask.Logictrl.LogictrlBit.quit= 1;
 166   2          if(LT.PipelineFlushingTask.Logictrl.LogictrlBit.execute)LT.PipelineFlushingTask.Logictrl.LogictrlBit.qui
             -t= 1;
 167   2          break;
 168   2          //=====================================================================// 3
 169   2          case status_Idle://ÊòæÁ§∫È¢ÑÁÉ≠Ê∏©Â∫¶Áä∂ÊÄÅÔºåÂêåÊó∂Â∫ï‰∏ãÊú∫Âô®ÊåÅÁª≠È¢ÑÁÉ≠ÔºåÂèëÈÄÅÊ∏©Â∫¶Áä∂ÊÄÅÔºåÁÑ∂Â
             -êéÊéßÂà∂ÊùøÊòæÁ§∫
 170   2          // if(AdPara.CurCoffeTemp<90)
 171   2          if((AdPara.CurCoffeTemp<(*CurSettingTemp))&&((*CurSettingTemp)-AdPara.CurCoffeTemp>=10)) //‰ΩéÊ∏©ÊèêÁ§∫‰
C51 COMPILER V9.54   MAIN                                                                  07/12/2025 08:10:58 PAGE 4   

             -Ωé10¬∞
 172   2          {
 173   3            ProcessTime++;//10msËÆ°Êï∞++
 174   3            if(ProcessTime < Delay_1S)//1sÂà∞
 175   3              Dis_PilotLamp(Led_Power|Led_Steam|Led_HotWater|Led_Clean|Led_Grind|Led_Temp);
 176   3            else if(ProcessTime < (2*Delay_1S))
 177   3              Dis_PilotLamp(Led_Power|Led_Clean|Led_Grind|Led_Temp);
 178   3            else
 179   3              ProcessTime =0;
 180   3          }
 181   2          else if((AdPara.CurCoffeTemp>(*CurSettingTemp))&&(AdPara.CurCoffeTemp-(*CurSettingTemp)>=15)) //È´òÊ∏©Êè
             -êÁ§∫È´ò15¬∞
 182   2          {
 183   3            ProcessTime++;
 184   3            if(ProcessTime < Delay_250ms)
 185   3              Dis_PilotLamp(Led_Power|Led_Steam|Led_HotWater|Led_Clean|Led_Grind|Led_Temp);
 186   3            else if(ProcessTime < (2*Delay_250ms))
 187   3              Dis_PilotLamp(Led_Power|Led_Clean|Led_Grind|Led_Temp);
 188   3            else
 189   3              ProcessTime =0;
 190   3          }
 191   2          else//‚ÄúËí∏Ê±Ω‚Äù‚ÄúÁÉ≠Ê∞¥‚ÄùÊåâÈîÆÁÅØÁî±Èó™ÁÉÅËΩ¨‰∏∫Èïø‰∫ÆÔºå‰ª£Ë°®È¢ÑÁÉ≠ÂÆåÊàê
 192   2          {
 193   3            Dis_PilotLamp(Led_Power|Led_Steam|Led_HotWater|Led_Clean|Led_Grind|Led_Temp);
 194   3          }
 195   2         #if   DEBUG_TEMP//ÂøΩÁï• 
                     Dis_Temperature(AdPara.CurCoffeTemp,curTempUnit); 
                 #else
 198   2            Dis_Temperature((*CurSettingTemp),curTempUnit);
 199   2         #endif // DEBUG    
 200   2          Dis_Function(CurFuntion);//ÊòæÁ§∫ÂΩìÂâçÂäüËÉΩÁÅØÔºåÂÆûÊó∂Êõ¥Êñ∞Ê®°ÂºèÁÅØ
 201   2          break;
 202   2          //=====================================================================// 4
 203   2          case status_Work://Â∑•‰ΩúÁä∂ÊÄÅ
 204   2          // if(LT.GrindBeanTask.Logictrl.LogictrlBit.execute==0)
 205   2          //     Dis_Temperature(AdPara.CurCoffeTemp,curTempUnit);
 206   2          break;
 207   2          //=====================================================================// 5
 208   2          case status_Steam://Ëí∏Ê±ΩÁä∂ÊÄÅ
 209   2        #if   DEBUG_TEMP 
                  Dis_Temperature(AdPara.CurCoffeTemp,curTempUnit);
                #endif // DEBUG    
 212   2          if(AdPara.CurCoffeTemp <140) 
 213   2          {
 214   3            ProcessTime++;
 215   3            if(ProcessTime < Delay_1S)
 216   3              Dis_PilotLamp(Led_Power|Led_Steam);
 217   3            else if(ProcessTime < (2*Delay_1S))
 218   3              Dis_PilotLamp(Led_Power);
 219   3            else
 220   3              ProcessTime =0;
 221   3          }
 222   2          else
 223   2            Dis_PilotLamp(Led_Power|Led_Steam);
 224   2          break;
 225   2          //=====================================================================// 6
 226   2          case status_Clean://Ê∏ÖÊ¥ÅÁä∂ÊÄÅ
 227   2          ProcessTime++; 
 228   2          if(ProcessTime < Delay_500ms)//500msÂª∂Êó∂
 229   2            ErrCode |= Descaling;//Ê∏ÖÊ¥ÅË≠¶Âëä
 230   2          else if(ProcessTime < (2*Delay_500ms))
 231   2            ErrCode &= (~Descaling);//ÂèñÊ∂à
C51 COMPILER V9.54   MAIN                                                                  07/12/2025 08:10:58 PAGE 5   

 232   2          else
 233   2            ProcessTime =0;
 234   2          break;
 235   2          //=====================================================================// 7
 236   2          case status_Set:
 237   2      
 238   2          break;
 239   2          //=====================================================================// 8
 240   2          case status_Err:
 241   2          Dis_PilotLamp(Led_Power);
 242   2          Dis_Error(ErrCode);
 243   2          if(ErrCode & ErrPotNtcHot)
 244   2             CodeDis(ERR,4);  //ÁÖ≤Ë∂ÖÊ∏© E-4
 245   2          else if(ErrCode & ErrPotNtcOpen)
 246   2             CodeDis(ERR,2);  //NTCÊñ≠Ë∑Ø E-2
 247   2          else if(ErrCode & ErrPotNtcShort)
 248   2             CodeDis(ERR,1);  //NTCÁü≠Ë∑Ø E-1
 249   2          if(LT.CleanTask.Logictrl.LogictrlBit.execute)LT.CleanTask.Logictrl.LogictrlBit.quit= 1;
 250   2          if(LT.GrindBeanTask.Logictrl.LogictrlBit.execute)LT.GrindBeanTask.Logictrl.LogictrlBit.quit= 1;
 251   2          if(LT.MakeCoffeTask.Logictrl.LogictrlBit.execute)LT.MakeCoffeTask.Logictrl.LogictrlBit.quit= 1;
 252   2          if(LT.MakeSteamTask.Logictrl.LogictrlBit.execute)LT.MakeSteamTask.Logictrl.LogictrlBit.quit= 1;
 253   2          if(LT.PotHeatTask.Logictrl.LogictrlBit.execute)LT.PotHeatTask.Logictrl.LogictrlBit.quit= 1;
 254   2          if(LT.MakeHotWaterTask.Logictrl.LogictrlBit.execute)LT.MakeHotWaterTask.Logictrl.LogictrlBit.quit= 1;
 255   2          if(LT.PipelineFlushingTask.Logictrl.LogictrlBit.execute)LT.PipelineFlushingTask.Logictrl.LogictrlBit.qui
             -t= 1;
 256   2          break;
 257   2          //=====================================================================// 9
 258   2          default:
 259   2            break;
 260   2          }
 261   1      }
 262          
 263          #define ErrdisTime 500//Á£®Ë±ÜÈîôËØØÊòæÁ§∫Âª∂Êó∂5Áßí
 264          void CheckGrining()//Á£®Ë±ÜÊ£ÄÊµã
 265          {
 266   1          static u16 ErrDisCnt=0;
 267   1          if(DirectOutput.OutputCtrlBit.GrindBean == DirOutPut_ON)
 268   1          {
 269   2          
 270   2              if(AdPara.AdMotor == NoWork)
 271   2              {
 272   3            //Á£®Ë±ÜÁîµÊú∫Êú™Â∑•‰Ωú Ë±Ü‰ªìÂÆâË£ÖÂºÇÂ∏∏
 273   3            ErrDisCnt++;
 274   3            if(ErrDisCnt >= 200)
 275   3            {
 276   4              ErrDisCnt = ErrdisTime;
 277   4              ErrCode |= ErrBeanWareHouse;
 278   4            }
 279   3              }
 280   2              else if (AdPara.AdMotor == NoLoad)
 281   2              {
 282   3                  //ÁîµÊú∫Á©∫ËΩ¨Êó†Ë±Ü
 283   3            ErrDisCnt++;
 284   3            if(ErrDisCnt >= 200)
 285   3            {
 286   4              ErrDisCnt = ErrdisTime;
 287   4              ErrCode |= ErrBeanLack;
 288   4            }
 289   3              }
 290   2              else if(AdPara.AdMotor ==Stall)
 291   2              {
 292   3                  //ÁîµÊú∫Â†µËΩ¨
C51 COMPILER V9.54   MAIN                                                                  07/12/2025 08:10:58 PAGE 6   

 293   3              }
 294   2              else if(AdPara.AdMotor == Grinding)
 295   2              {
 296   3                  ErrDisCnt++;
 297   3                  if(ErrDisCnt >= 100)
 298   3                  {
 299   4                      ErrCode &= (~ErrBeanWareHouse);
 300   4                      ErrCode &= (~ErrBeanLack);
 301   4                  }
 302   3              }
 303   2          }
 304   1          else if(ErrDisCnt) 
 305   1          {
 306   2             ErrDisCnt--; 
 307   2          }
 308   1        else
 309   1        {
 310   2             ErrCode &= (~ErrBeanWareHouse);
 311   2             ErrCode &= (~ErrBeanLack);
 312   2        }
 313   1      }
 314          
 315          void SleepCtrl()//‰ºëÁú†ËÆæÁΩÆ
 316          {
 317   1          if(DeviceStatus > status_Down)
 318   1          {
 319   2              if(SleepCut >= SleepTime)
 320   2              {
 321   3                  AllDown();
 322   3                  DeviceStatus = status_Down;
 323   3              }
 324   2          }
 325   1      }
 326          
 327          //‰∏≤Âè£Êï∞ÊçÆÂà∑Êñ∞
 328          void SerialPortDataRefresh()
 329          {
 330   1          if(QueueFinDataFrame(&LoopUart,cmd_buffer)>0)
 331   1              ProcessMessage((PCTRL_MSG)cmd_buffer);
 332   1      }
 333          
 334          
 335          void main(void)
 336          {
 337   1          MCU_init();
 338   1          while (1)
 339   1          {
 340   2             SerialPortDataRefresh();
 341   2             ScanEncoder();
 342   2             Logic();
 343   2             if(ProcessCount>=DIV_10MS)
 344   2             {
 345   3                  ProcessCount=0;
 346   3                  Scan();//ÊåâÈîÆÊâ´Êèè
 347   3                  Respone();//ÊåâÈîÆÂõûË∞É
 348   3                  FlowCheck();//ÊµÅÊéß
 349   3                  CheckSensor();//Ê∏©Â∫¶Ê£ÄÊµã
 350   3                  CheckGrining();//Á£®Ë±ÜÊ£ÄÊµã
 351   3            BeepCtrl();//ËúÇÈ∏£Âô®ÊéßÂà∂
 352   3                  mainTask();//‰∏ªÁä∂ÊÄÅ
 353   3                  SleepCtrl();//‰ºëÁú†Ê£ÄÊµã
 354   3            DisRefresh();//ÊòæÁ§∫ÊéßÂà∂
C51 COMPILER V9.54   MAIN                                                                  07/12/2025 08:10:58 PAGE 7   

 355   3             }
 356   2          }
 357   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1211    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    241    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
