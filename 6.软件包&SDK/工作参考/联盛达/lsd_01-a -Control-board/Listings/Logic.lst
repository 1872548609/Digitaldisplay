C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN .\Objects\Logic.obj
COMPILER INVOKED BY: E:\keilC51\C51\BIN\C51.EXE scr\Logic.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\inc;.\USER) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\Logic.lst) TABS(2) OBJECT(.\Objects\Logic.obj)

line level    source

   1          #include "Logic.h"
   2          
   3          
   4          
   5          Task xdata LogicTask ={0};
   6          
   7          u8 FlashUartByte(u8 newStatus)//‰∏≤Âè£ÂëΩ‰ª§Ë∑üÊñ∞
   8          {
   9   1          if((UartFlag &newStatus)==0)
  10   1          {
  11   2              UartFlag |=newStatus;
  12   2              return 1;
  13   2          }
  14   1          else
  15   1              return 0;
  16   1      }
  17          
  18          void ProgramInit(LogicParaDef*p )//ÂàùÂßãÂåñ‰ªªÂä°
  19          {
  20   1          TASK_QUIT
  21   1          {
  22   2              CtrlPara.execute = 0;
  23   2              CtrlPara.quit    = 0;
  24   2              CtrlPara.step    = 0;
  25   2          }
  26   1          TASK_PROCESS
  27   1          {
  28   2              case 1:
  29   2              if(FlashUartByte(CMD_FlowCtrl|CMD_SteamHeat|CMD_LampCtrl))//ÊµÅÈáèËÆ°ÔºåËí∏Ê±ΩÂä†ÁÉ≠ÔºåÁÖßÊòé
  30   2              {
  31   3            //Êé•ÈÄöÁîµÊ∫êÔºåÊú∫Âô®ÈïøÂìç‰∏ÄÂ£∞(Êª¥1s)ÔºåÊâÄÊúâÁÅØÂèäÊòæÁ§∫ÂÖ®‰∫Æ1sÂêéÁÜÑÁÅ≠Ôºõ‰ªÖ‚ÄúÁîµÊ∫ê‚ÄùÊåâÈî
             -ÆÁÅØÈó™ÁÉÅÔºàÈó¥Èöî1s/Èó™Ôºâ„ÄÇ
  32   3                  buzctrl.BeepState = BeepOnce;//ËúÇÈ∏£Âô®È∏£Âìç‰∏ÄÂ£∞ 
  33   3            AllUp();//ÁÅØÂÖ®ÂºÄ
  34   3            
  35   3             LampCtrl.CtrlByte = FULL_POWER;//ÂÖ®ÂäüÁéáÂä†ÁÉ≠
  36   3                  FlowCtrl.PulsePeriod = PulsePerMl;//ÊµÅÈáèÊØèÂçá‰∏§‰∏™ËÑâÂÜ≤
  37   3                  PotHeatCtrl.Period   = 80;//Âä†ÁÉ≠Âë®Êúü
  38   3            
  39   3                  buzctrl.BeepDuration = Buz_1S;
  40   3                  ReadTotalFlow();//ËØªÂèñÊÄªÊµÅÈáè
  41   3                  ReadSingleEspTemp(); //ËØªÂèñÊ∏©Â∫¶
  42   3                  ReadDoubleEspTemp();//ËØªÂèñÂèåÊùØÊ∏©Â∫¶
  43   3                  ReadCoffeTemp();//ËØªÂèñÂíñÂï°Ê∏©Â∫¶
  44   3                  ReadAmericanoTemp();//ËØªÁæéÂºèÊ∏©Â∫¶
  45   3                
  46   3                  TimerRes(&Tim);///ËØªÂèñÂΩìÂâçÊó∂Èó¥
  47   3                  CtrlPara.step = 2;//ËøõÂÖ•Ê≠•È™§2
  48   3              }
  49   2             break;
  50   2              case 2:
  51   2                  if(GetTime(Tim,DIV_1S)>= 1)//‰∏ÄÁßíÂêé
  52   2                  {
  53   3                      if(FlashUartByte(CMD_LampCtrl))//Êõ¥Êñ∞ÁÖßÊòéÊéßÂà∂
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 2   

  54   3                      {
  55   4                          LampCtrl.CtrlByte = All_Down;//ÁÖßÊòéÂÖ®ÂÖ≥
  56   4                          AllDown();//ÊéßÂà∂ÊùøÁÅØÂÖ®ÂÖ≥
  57   4                          CtrlPara.step = 3;//ËøõÂÖ•Ê≠•È™§3
  58   4                      }
  59   3                  }
  60   2              break;
  61   2              case 3:
  62   2                  DeviceStatus = status_Down;//ÂàùÂßãÂåñÂÆåÊØïÂÖ≥Êú∫
  63   2                  CtrlPara.execute = 0;
  64   2                  CtrlPara.quit    = 0;
  65   2                  CtrlPara.step    = 0;
  66   2              break;
  67   2          }
  68   1      }
  69          
  70          
  71          
  72          void Makecoffe(LogicParaDef*p )//ÂÅöÂíñÂï°ÔºåÊåâ‰∏ãËêÉÂèñÂêéÁöÑÂä®‰Ωú
  73          {
  74   1          TASK_QUIT
  75   1          {
  76   2              if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
  77   2              {
  78   3                  DirectOutput.OutputCtrlBit.CoffeValve = DirOutPut_OFF;
  79   3                  DirectOutput.OutputCtrlBit.HotWaterValve= DirOutPut_OFF;
  80   3                  FlowCtrl.FlowCtrlByte = Flow_End;
  81   3                  PumpCtrl.workFlag = OFF;
  82   3                  CtrlPara.execute = 0;
  83   3                  CtrlPara.quit    = 0;
  84   3                  CtrlPara.step    = 0;
  85   3              }
  86   2          }
  87   1          TASK_PROCESS
  88   1          {
  89   2          //=====================================================================// 1
  90   2              case 1:
  91   2            Dis_Temperature(0,NoUnitDis);//Ê∏©Â∫¶ÊòæÁ§∫0
  92   2              if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))//Êõ¥Êñ∞‰∏≤Âè£ÂëΩ‰ª§
  93   2              {
  94   3                  DirectOutput.OutputCtrlBit.CoffeValve = DirOutPut_ON;//ÂºÄÂêØÂíñÂï°ÁîµÁ£ÅÈòÄ
  95   3                  if(CurFuntion == ColdBrew)//ÂÜ∑Áø†ÂäüËÉΩ
  96   3                  {
  97   4                      PumpCtrl.Duty   = 400;  //ÂºÄ0.5ÂÖ≥0.5
  98   4                      PumpCtrl.Period = 800;
  99   4                      CtrlPara.step = 4;//ËøõÊ≠•È™§4
 100   4                  }
 101   3                  else//‰∏çÊòØÂÜ∑Áø†ÂäüËÉΩ
 102   3                  {
 103   4                      PumpCtrl.Duty   = 100; //Ê∞¥Ê≥µÂç†Á©∫ÊØî
 104   4                      PumpCtrl.Period = 100;
 105   4                      CtrlPara.step = 2;//ËøõÊ≠•È™§2
 106   4                  }
 107   3                  FlowCtrl.FlowCtrlByte = Flow_Scan;//ÊµÅÈáèÂêØÂä®
 108   3                  PumpCtrl.workFlag = ON;//Ê∞¥Ê≥µPWMÂºÄÂêØ
 109   3                  TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 110   3              }
 111   2              break;
 112   2          //=====================================================================// 2
 113   2              case 2:
 114   2              EndDis=GetTime(Tim,DIV_1S);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥Èó¥Èöî
 115   2              Dis_Temperature(EndDis,NoUnitDis);//ÊòæÁ§∫Êó∂Èó¥
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 3   

 116   2              if(EndDis>= PreInjectionTime)//Â§ß‰∫éÈ¢ÑÊ≥®Ê∞¥Êó∂Èó¥ÔºåÊ≥®Ê∞¥ÂÆåÊàê
 117   2              {
 118   3                  if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl)) 
 119   3                  {
 120   4                      DirectOutput.OutputCtrlBit.CoffeValve= DirOutPut_OFF;//ÂíñÂï°ÁîµÁ£ÅÈòÄÂÖ≥Èó≠
 121   4                      FlowCtrl.FlowCtrlByte = Flow_End;//ÂÖ≥Èó≠ÊµÅÊéß
 122   4                      PumpCtrl.workFlag = OFF;//ÂÅúÊ≠¢Ê≥µ
 123   4                      CtrlPara.step = 3;//ËøõÊ≠•È™§3
 124   4                  }
 125   3              }
 126   2              break;
 127   2          //=====================================================================// 3
 128   2              case 3:
 129   2              EndDis=GetTime(Tim,DIV_1S);
 130   2              Dis_Temperature(EndDis,NoUnitDis);//Âª∂Êó∂Êó∂Èó¥
 131   2              if(EndDis>= (4+PreInjectionTime))//Âª∂Êó∂Êó∂Èó¥Â§ß‰∫éÊ≥®Ê∞¥ÂêéÂÅúÊ≠¢4s
 132   2              {
 133   3                  if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))//ÊâìÂºÄËí∏Ê±ΩÊ≥µÔºåÊâìÂºÄÊµÅÊéß
 134   3                  {
 135   4                      DirectOutput.OutputCtrlBit.CoffeValve= DirOutPut_ON;//ÊâìÂºÄÂíñÂï°ÁîµÁ£ÅÈòÄ
 136   4                      FlowCtrl.FlowCtrlByte = Flow_Scan;//ÂºÄÂêØÊµÅÊéß
 137   4                      PumpCtrl.workFlag= ON; //ÂÖ≥Èó≠Ê∞¥Ê≥µ
 138   4                      CtrlPara.step = 4;//ËøõÂÖ•Ê≠•È™§4
 139   4                  }
 140   3              }
 141   2              break;
 142   2          //=====================================================================// 4
 143   2              case 4:
 144   2              EndDis=GetTime(Tim,DIV_1S);
 145   2              Dis_Temperature(EndDis,NoUnitDis);
 146   2              if(CurFlow >= MakeFlow)//ÂΩìÂâçÊµÅÈáèÔºåËææÂà∞Â∑•‰ΩúÊµÅÈáè
 147   2              {
 148   3                  if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 149   3                  {
 150   4                      DirectOutput.OutputCtrlBit.CoffeValve= DirOutPut_OFF;//ÂÖ≥Èó≠ÁîµÁ£ÅÈòÄ
 151   4                      FlowCtrl.FlowCtrlByte = Flow_End;//ÊµÅÊéßÂÖ≥Èó≠
 152   4                      PumpCtrl.workFlag = OFF;//Ê∞¥Ê≥µÂÖ≥Èó≠
 153   4                      TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 154   4                      if(CurFuntion == Americano)//ÂΩìÂâçÊòØÁæéÂºè
 155   4                      CtrlPara.step = 5;//ËøõÊ≠•È™§5
 156   4                      else
 157   4                      CtrlPara.step = 7;//Âê¶ÂàôËøõÊ≠•È™§7
 158   4                  }
 159   3              }
 160   2              break;
 161   2          //=====================================================================// 5
 162   2              case 5://ÁæéÂºèÊ≠•È™§1
 163   2              EndDis += GetTime(Tim,DIV_1S);
 164   2              Dis_Temperature(EndDis,NoUnitDis);
 165   2              if(GetTime(Tim,DIV_1S)>= 1)     
 166   2              {
 167   3                  if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 168   3                  {
 169   4                      DirectOutput.OutputCtrlBit.HotWaterValve= DirOutPut_ON;//ÂºÄÂêØÂíñÂï°ÁîµÁ£ÅÈòÄ
 170   4                      FlowCtrl.FlowCtrlByte = Flow_Scan;//ÊâìÂºÄÊµÅÊéß
 171   4                      PumpCtrl.workFlag= ON; //ÂºÄÂêØÊ∞¥Ê≥µ
 172   4                      CtrlPara.step = 6;//ËøõÊ≠•È™§6
 173   4                  }
 174   3              }
 175   2              break;
 176   2          //=====================================================================// 6
 177   2              case 6://ÁæéÂºèÊ≠•È™§2
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 4   

 178   2              EndDis += GetTime(Tim,DIV_1S);
 179   2              Dis_Temperature(EndDis,NoUnitDis);
 180   2              if(CurFlow >= 85)//ÊµÅÈáèÂ§ß‰∫é85
 181   2              {
 182   3                  if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 183   3                  {
 184   4                      DirectOutput.OutputCtrlBit.HotWaterValve= DirOutPut_OFF;//ÂÖ≥Èó≠ÂíñÂï°ÁîµÁ£ÅÈòÄ
 185   4                      FlowCtrl.FlowCtrlByte = Flow_End;//ÂÖ≥Èó≠ÊµÅÊéß
 186   4                      PumpCtrl.workFlag = OFF;//ÂÖ≥Èó≠Ê∞¥Ê≥µ
 187   4                      CtrlPara.step = 7;//ËøõÊ≠•È™§7ÈÄÄÂá∫Âà∂‰ΩúÂíñÂï°
 188   4                  }
 189   3              }
 190   2              break;
 191   2          //=====================================================================// 7
 192   2              case 7://ÂõûÂΩíÊòæÁ§∫Áä∂ÊÄÅÔºåÂÆåÊàêÂà∂‰ΩúÂíñÂï°
 193   2                  DeviceStatus = status_Idle;
 194   2                  CtrlPara.execute = 0;
 195   2                  CtrlPara.quit    = 0;
 196   2                  CtrlPara.step    = 0;
 197   2              break;
 198   2          }
 199   1      }
 200          
 201          void MakeSteam(LogicParaDef*p )//ÂºÄËí∏Ê±Ω
 202          {
 203   1          TASK_QUIT
 204   1          {
 205   2              if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 206   2              {
 207   3                  DirectOutput.OutputCtrlBit.SteamValve = DirOutPut_OFF;
 208   3                  DirectOutput.OutputCtrlBit.CoffeValve = DirOutPut_OFF;
 209   3                  FlowCtrl.FlowCtrlByte = Flow_End;
 210   3                  PumpCtrl.workFlag = OFF;
 211   3                  CtrlPara.execute = 0;
 212   3                  CtrlPara.quit    = 0;
 213   3                  CtrlPara.step    = 0;
 214   3              }
 215   2          }
 216   1          TASK_PROCESS
 217   1          {
 218   2              case 1:
 219   2      #if !DEBUG_TEMP 
 220   2              Dis_Temperature(0,NoUnitDis);//ÊòæÁ§∫0
 221   2      #endif
 222   2              if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 223   2              {
 224   3                  DirectOutput.OutputCtrlBit.SteamValve = DirOutPut_ON;//ÂºÄÂêØËí∏Ê±ΩÁîµÁ£ÅÈòÄ
 225   3                  FlowCtrl.FlowCtrlByte = Flow_Scan;//ÊâìÂºÄÊµÅÈáèËÆ°
 226   3                  PumpCtrl.Duty       = 16;//Ê∞¥Ê≥µÂç†Á©∫ÊØî
 227   3                  PumpCtrl.Period     = 280;
 228   3                  PumpCtrl.workFlag  = ON;//Ê∞¥Ê≥µÂ∑•‰Ωú
 229   3                  TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 230   3                  CtrlPara.step = 2;//ËøõÂÖ•Ê≠•È™§2
 231   3              }
 232   2              break;
 233   2              case 2:
 234   2      #if !DEBUG_TEMP 
 235   2              EndDis=GetTime(Tim,DIV_1S);
 236   2              Dis_Temperature(EndDis,NoUnitDis);//ÊòæÁ§∫Êó∂Èó¥
 237   2      #endif
 238   2              if(GetTime(Tim,DIV_1S)>= MaxSteamTime)//Êó∂Èó¥Â§ß‰∫éÊúÄÂ§ßÂá∫Ëí∏Ê±ΩÊó∂Èó¥
 239   2              {
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 5   

 240   3                  DirectOutput.OutputCtrlBit.SteamValve = DirOutPut_OFF;//ÂÖ≥Èó≠Ëí∏Ê±ΩÁîµÁ£ÅÈòÄ
 241   3                  FlowCtrl.FlowCtrlByte = Flow_End;//ÂÖ≥Èó≠ÊµÅÈáèËÆ°
 242   3                  PumpCtrl.workFlag = OFF;//ÂÅúÊ≠¢Ê∞¥Ê≥µ
 243   3                  CtrlPara.step = 3;//ËøõÂÖ•Ê≠•È™§4
 244   3              }
 245   2              break;
 246   2              case 3:
 247   2                  DeviceStatus = status_Idle;//ÂõûÂà∞ÊòæÁ§∫Ê®°Âºè
 248   2                  CtrlPara.execute = 0;
 249   2                  CtrlPara.quit    = 0;
 250   2                  CtrlPara.step    = 0;
 251   2              break;
 252   2          }
 253   1      }
 254          
 255          void MakeHotWater(LogicParaDef*p )//ÂºÄÁÉ≠Ê∞¥
 256          {
 257   1          TASK_QUIT
 258   1          {
 259   2              if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 260   2              {
 261   3                  DirectOutput.OutputCtrlBit.HotWaterValve= DirOutPut_OFF;
 262   3                  FlowCtrl.FlowCtrlByte = Flow_End;
 263   3                  PumpCtrl.workFlag = OFF;
 264   3                  CtrlPara.execute = 0;
 265   3                  CtrlPara.quit    = 0;
 266   3                  CtrlPara.step    = 0;
 267   3              }
 268   2          }
 269   1          TASK_PROCESS
 270   1          {
 271   2              case 1:
 272   2              Dis_Temperature(0,NoUnitDis);
 273   2              if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 274   2              {
 275   3                  DirectOutput.OutputCtrlBit.HotWaterValve= DirOutPut_ON;//ÂºÄÂêØÁÉ≠Ê∞¥ÁîµÁ£ÅÈòÄ
 276   3                  FlowCtrl.FlowCtrlByte = Flow_Scan;//ÊâìÂºÄÊµÅÈáèËÆ°
 277   3                  PumpCtrl.Duty   = 100;//ËÆæÁΩÆÊ∞¥Ê≥µÂ∑•‰ΩúÂç†Á©∫ÊØî
 278   3                  PumpCtrl.Period = 100;
 279   3                  PumpCtrl.workFlag = ON;
 280   3                  TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 281   3                  CtrlPara.step = 2;//ËøõÂÖ•Ê≠•È™§2
 282   3              }
 283   2              break;
 284   2              case 2:
 285   2              EndDis=GetTime(Tim,DIV_1S);
 286   2              Dis_Temperature(EndDis,NoUnitDis);
 287   2              if(GetTime(Tim,DIV_1S)>= MaxWaterTime)//Âª∂Êó∂ÊúÄÂ§ßÁÉ≠Ê∞¥Êó∂Èó¥
 288   2              {
 289   3                  if(FlashUartByte(CMD_DirOutput|CMD_SteamPump|CMD_FlowCtrl))
 290   3                  {
 291   4                      DirectOutput.OutputCtrlBit.HotWaterValve= DirOutPut_OFF;//ÂÖ≥Èó≠ÁÉ≠Ê∞¥ÁîµÁ£ÅÈòÄ
 292   4                      FlowCtrl.FlowCtrlByte = Flow_End;//ÂÖ≥Èó≠ÊµÅÈáèËÆ°
 293   4                      PumpCtrl.workFlag = OFF;//ÂÅúÊ≠¢Ê∞¥Ê≥µ
 294   4                      CtrlPara.step = 3;
 295   4                  }
 296   3              }
 297   2              break;
 298   2              case 3:
 299   2          DeviceStatus = status_Idle;//ÂõûÂà∞ÊòæÁ§∫Ê®°Âºè
 300   2              CtrlPara.execute = 0;
 301   2              CtrlPara.quit    = 0;
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 6   

 302   2              CtrlPara.step    = 0;
 303   2              break;
 304   2          }                                                               
 305   1      
 306   1      }
 307          
 308          void Grind(LogicParaDef*p )//Á£®Ë±Ü
 309          {
 310   1          TASK_QUIT
 311   1          {
 312   2              if(FlashUartByte(CMD_DirOutput|CMD_LampCtrl))
 313   2              {
 314   3                  LampCtrl.CtrlByte = All_Down;
 315   3                  DirectOutput.OutputCtrlBit.Plasma    = DirOutPut_OFF;
 316   3                  DirectOutput.OutputCtrlBit.GrindBean = DirOutPut_OFF;
 317   3            
 318   3                  CtrlPara.execute = 0;
 319   3                  CtrlPara.quit    = 0;
 320   3                  CtrlPara.step    = 0;
 321   3              }
 322   2          }
 323   1          TASK_PROCESS
 324   1          {
 325   2              case 1:
 326   2              TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 327   2              CtrlPara.step = 2;//ËøõÂÖ•Ê≠•È™§2
 328   2              break;
 329   2              case 2:
 330   2            Dis_Temperature(GrindTime,NoUnitDis);//ÊòæÁ§∫Á£®Ë±ÜÊ∏©Â∫¶ÔºåÊó†Âçï‰ΩçËΩ¨Êç¢
 331   2              if(GetTime(Tim,DIV_1S)>= 3)//3sÂêé
 332   2              {
 333   3                  CtrlPara.step = 3;//ËøõÂÖ•Ê≠•È™§3
 334   3              }
 335   2          break;
 336   2              case 3:
 337   2              // Dis_Temperature(GrindTime,NoUnitDis);
 338   2              if(FlashUartByte(CMD_DirOutput|CMD_LampCtrl))//‰∏≤Âè£ÂëΩ‰ª§Ë∑üÊñ∞ÔºåÊâìÂºÄÁÖßÊòéÔºåÁõ¥Êé•ËæìÂá∫Êéß
             -Âà∂
 339   2              {
 340   3                  LampCtrl.CtrlByte = FULL_POWER;//ÂÖ®ÂäüÁéáÂºÄÁÅØ
 341   3                  DirectOutput.OutputCtrlBit.Plasma    = DirOutPut_ON;//ÊâìÂºÄÁ≠âÁ¶ªÂ≠ê
 342   3                  DirectOutput.OutputCtrlBit.GrindBean = DirOutPut_ON;//ÊâìÂºÄÁ£®Ë±Ü
 343   3                  TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 344   3                  CtrlPara.step = 4;//ËøõÂÖ•Ê≠•È™§4
 345   3              }
 346   2          break;
 347   2              case 4:
 348   2          Dis_Temperature((GrindTime-GetTime(Tim,DIV_1S)),NoUnitDis);//ÊòæÁ§∫Ê∏©Â∫¶‰ΩçÁΩÆÊòæÁ§∫Êó∂Èó¥ÂÄíËÆ°Êó∂ÂêéË
             -á™Âä®ÁªìÊùü
 349   2              if(GetTime(Tim,DIV_1S)>= GrindTime)//Â¶ÇÊûúÂª∂Êó∂Â§ß‰∫éÁ£®Ë±ÜÊó∂Èó¥
 350   2              {
 351   3                  if(FlashUartByte(CMD_DirOutput|CMD_LampCtrl))//ÂÖ≥Èó≠ÁÅØÊòæ
 352   3                  {
 353   4                      LampCtrl.CtrlByte = All_Down;//ÂÖ≥Èó≠
 354   4                      DirectOutput.OutputCtrlBit.Plasma    = DirOutPut_OFF;//ÂÖ≥Èó≠Á≠âÁ¶ªÂ≠êÂíåÁ£®Ë±Ü
 355   4                      DirectOutput.OutputCtrlBit.GrindBean = DirOutPut_OFF;
 356   4                      CtrlPara.step = 5;
 357   4                  }
 358   3              }
 359   2          break;
 360   2              case 5:
 361   2                  DeviceStatus = status_Idle;//ÂõûÂà∞ÊòæÁ§∫Áä∂ÊÄÅ
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 7   

 362   2                  CtrlPara.execute = 0;
 363   2                  CtrlPara.quit    = 0;
 364   2                  CtrlPara.step    = 0;
 365   2          break;
 366   2          }
 367   1      }
 368          
 369          
 370          void PotHeat(LogicParaDef*p )//Âä†ÁÉ≠
 371          {
 372   1          TASK_QUIT
 373   1          {
 374   2              if(FlashUartByte(CMD_SteamHeat))
 375   2              {
 376   3                  PotHeatCtrl.workFlag = OFF;
 377   3                  CtrlPara.execute = 0;
 378   3                  CtrlPara.quit    = 0;
 379   3                  CtrlPara.step    = 0;
 380   3              }
 381   2          }
 382   1          TASK_PROCESS
 383   1          {
 384   2             case 1:
 385   2             if(LT.MakeCoffeTask.Logictrl.LogictrlBit.execute)//ÊâßË°åÂà∂‰ΩúÂíñÂï°
 386   2                 CtrlPara.step = 2;
 387   2             else if(LT.MakeSteamTask.Logictrl.LogictrlBit.execute)//ÊâßË°åËí∏Ê±Ω
 388   2                  CtrlPara.step = 3;
 389   2             else if (LT.MakeHotWaterTask.Logictrl.LogictrlBit.execute)//ÊâßË°åÁÉ≠Ê∞¥
 390   2                  CtrlPara.step = 4;
 391   2             else if(DeviceStatus == status_Steam)//Ëí∏Ê±ΩÁä∂ÊÄÅ
 392   2                  CtrlPara.step = 5;
 393   2             else if(DeviceStatus == status_Idle)//ÊòæÁ§∫Áä∂ÊÄÅ
 394   2                  CtrlPara.step = 6;
 395   2             else
 396   2             {
 397   3                  if(FlashUartByte(CMD_SteamHeat))
 398   3                      PotHeatCtrl.workFlag = OFF;//ÂÖ≥Èó≠Âä†ÁÉ≠
 399   3             }
 400   2             break;
 401   2             case 2: //ÂÅöÂíñÂï°Âä†ÁÉ≠
 402   2             if(LT.MakeCoffeTask.Logictrl.LogictrlBit.execute==0)
 403   2                  CtrlPara.step = 1;
 404   2             if(AdPara.CurCoffeTemp<CurPotAimTemp)
 405   2             {
 406   3                  if(FlashUartByte(CMD_SteamHeat))
 407   3                  {
 408   4                      PotHeatCtrl.Duty   = 80;
 409   4                      PotHeatCtrl.workFlag = ON;
 410   4                  }
 411   3             }
 412   2             else 
 413   2             {
 414   3                  if(FlashUartByte(CMD_SteamHeat))
 415   3                      PotHeatCtrl.workFlag = OFF;
 416   3             }
 417   2             break;
 418   2             case 3: //ÂÅöËí∏Ê±ΩÂä†ÁÉ≠
 419   2              if(LT.MakeSteamTask.Logictrl.LogictrlBit.execute==0)
 420   2                  CtrlPara.step = 1;
 421   2              if(AdPara.CurCoffeTemp<142)
 422   2              {
 423   3                  if(FlashUartByte(CMD_SteamHeat))
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 8   

 424   3                  {
 425   4                      PotHeatCtrl.Duty   = 80;
 426   4                      PotHeatCtrl.workFlag = ON;
 427   4                  }
 428   3              }
 429   2              else if (AdPara.CurCoffeTemp<152)
 430   2              {
 431   3                  if(FlashUartByte(CMD_SteamHeat))
 432   3                  {
 433   4                      PotHeatCtrl.Duty   = 55;
 434   4                      PotHeatCtrl.workFlag = ON;
 435   4                  }
 436   3              }
 437   2              else if (AdPara.CurCoffeTemp<160)
 438   2              {
 439   3                  if(FlashUartByte(CMD_SteamHeat))
 440   3                  {
 441   4                      PotHeatCtrl.Duty   = 20;
 442   4                      PotHeatCtrl.workFlag = ON;
 443   4                  }
 444   3              }
 445   2              else 
 446   2              {
 447   3                  if(FlashUartByte(CMD_SteamHeat))
 448   3                      PotHeatCtrl.workFlag = OFF;
 449   3              }
 450   2             break;
 451   2             case 4: //ÂÅöÁÉ≠Ê∞¥Âä†ÁÉ≠
 452   2              if(LT.MakeHotWaterTask.Logictrl.LogictrlBit.execute==0)
 453   2                  CtrlPara.step = 1;
 454   2              if(AdPara.CurCoffeTemp<110)
 455   2              {
 456   3                  if(FlashUartByte(CMD_SteamHeat))    
 457   3                  {
 458   4                      PotHeatCtrl.Duty   = 80;
 459   4                      PotHeatCtrl.workFlag = ON;
 460   4                  }
 461   3              }
 462   2              else 
 463   2              {
 464   3                  if(FlashUartByte(CMD_SteamHeat))
 465   3                      PotHeatCtrl.workFlag = OFF;
 466   3              }
 467   2             break;
 468   2             case 5: //Ëí∏Ê±ΩÈ¢ÑÁÉ≠
 469   2              if(LT.MakeSteamTask.Logictrl.LogictrlBit.execute||(DeviceStatus != status_Steam))
 470   2                  CtrlPara.step = 1;
 471   2              if(AdPara.CurCoffeTemp<100)
 472   2              {
 473   3                  if(FlashUartByte(CMD_SteamHeat))
 474   3                  {
 475   4                      PotHeatCtrl.Duty   = 80;
 476   4                      PotHeatCtrl.workFlag = ON;
 477   4                  }
 478   3              }
 479   2              else if (AdPara.CurCoffeTemp<120)
 480   2              {
 481   3                  if(FlashUartByte(CMD_SteamHeat))
 482   3                  {
 483   4                      PotHeatCtrl.Duty   = 37;
 484   4                      PotHeatCtrl.workFlag = ON;
 485   4                  }
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 9   

 486   3              }
 487   2              else if (AdPara.CurCoffeTemp<142)
 488   2              {
 489   3                  if(FlashUartByte(CMD_SteamHeat))
 490   3                  {
 491   4                      PotHeatCtrl.Duty   = 10;
 492   4                      PotHeatCtrl.workFlag = ON;
 493   4                  }
 494   3              }
 495   2              else 
 496   2              {
 497   3                  if(FlashUartByte(CMD_SteamHeat))
 498   3                      PotHeatCtrl.workFlag = OFF;
 499   3              }
 500   2      
 501   2             break;
 502   2             case 6://ÂíñÂï°È¢ÑÁÉ≠
 503   2             if(DeviceStatus != status_Idle)
 504   2                  CtrlPara.step = 1;
 505   2              if(AdPara.CurCoffeTemp<(CurPotAimTemp-25))
 506   2              {
 507   3                  if(FlashUartByte(CMD_SteamHeat))
 508   3                  {
 509   4                      PotHeatCtrl.Duty   = 80;
 510   4                      PotHeatCtrl.workFlag = ON;
 511   4                  }
 512   3              }
 513   2              else if(AdPara.CurCoffeTemp<CurPotAimTemp)
 514   2              {
 515   3                  if(FlashUartByte(CMD_SteamHeat))
 516   3                  {
 517   4                      PotHeatCtrl.Duty   = 20;
 518   4                      PotHeatCtrl.workFlag = ON;
 519   4                  }
 520   3              }
 521   2              else 
 522   2              {
 523   3                  if(FlashUartByte(CMD_SteamHeat))
 524   3                      PotHeatCtrl.workFlag = OFF;
 525   3              }
 526   2             break;
 527   2          }
 528   1      }
 529          
 530          void Clean(LogicParaDef*p )//Ê∏ÖÊ¥Å‰ªªÂä°
 531          {
 532   1          static u8 CleanCount = 0;
 533   1          TASK_QUIT
 534   1          {
 535   2              if(FlashUartByte(CMD_DirOutput|CMD_FlowCtrl|CMD_SteamPump))
 536   2              {
 537   3                  DirectOutput.OutputCtrlBit.CoffeValve = DirOutPut_OFF;
 538   3                  FlowCtrl.FlowCtrlByte = Flow_End;
 539   3                  PumpCtrl.workFlag = OFF;
 540   3                  CtrlPara.execute = 0;
 541   3                  CtrlPara.quit    = 0;
 542   3                  CtrlPara.step    = 0;
 543   3              }
 544   2          }
 545   1          TASK_PROCESS    
 546   1          {
 547   2              case 1:
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 10  

 548   2              if(FlashUartByte(CMD_DirOutput|CMD_FlowCtrl|CMD_SteamPump))
 549   2              {
 550   3                  TotalFlow = 0;
 551   3                  DirectOutput.OutputCtrlBit.CoffeValve = DirOutPut_ON;//ÊâìÂºÄÂíñÂï°ÁîµÁ£ÅÈòÄ
 552   3                  FlowCtrl.FlowCtrlByte = Flow_Scan;//ÊâìÂºÄÊµÅÈáèËÆ°
 553   3                  PumpCtrl.Duty   = 100;
 554   3                  PumpCtrl.Period = 100;//Ê∞¥Ê≥µÂç†Á©∫ÊØî
 555   3                  PumpCtrl.workFlag = ON;//Ê∞¥Ê≥µÂ∑•‰Ωú
 556   3                  TimerRes(&Tim);//ÂΩìÂâçÊó∂Èó¥
 557   3                  CleanCount = 0;
 558   3                  CtrlPara.step = 2;//ËøõÂÖ•Ê≠•È™§2
 559   3              }
 560   2              break;
 561   2              case 2:
 562   2              if(GetTime(Tim,DIV_1S)>= 8)//8ÁßíÂª∂Êó∂
 563   2              {
 564   3                  if(FlashUartByte(CMD_DirOutput|CMD_FlowCtrl|CMD_SteamPump))
 565   3                  {
 566   4                      DirectOutput.OutputCtrlBit.CoffeValve = DirOutPut_OFF;//ÂÖ≥Èó≠
 567   4                      FlowCtrl.FlowCtrlByte = Flow_End;//ÂÖ≥Èó≠ÊµÅÈáèËÆ°
 568   4                      PumpCtrl.workFlag = OFF;//ÂÖ≥Èó≠Ê∞¥Ê≥µ
 569   4                      TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 570   4                      CtrlPara.step = 3;
 571   4                  }
 572   3              }
 573   2              break;
 574   2              case 3: 
 575   2              if(GetTime(Tim,DIV_1S)>= 4) //4sÂª∂Êó∂
 576   2              {
 577   3                  if(FlashUartByte(CMD_DirOutput|CMD_FlowCtrl|CMD_SteamPump))//ÊµÅÈáèËÆ°ÂíåËí∏Ê±ΩÊ∞¥Ê≥µÊéßÂà∂
 578   3                  {
 579   4                      DirectOutput.OutputCtrlBit.CoffeValve = DirOutPut_ON;//ÂºÄÂêØ
 580   4                      FlowCtrl.FlowCtrlByte = Flow_Scan;//ÊµÅÈáèËÆ°ÊâìÂºÄ
 581   4                      PumpCtrl.workFlag = ON;//Â∑•‰Ωú
 582   4                      TimerRes(&Tim);//Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
 583   4                      CleanCount++;//ËÆ°Êó∂50ms
 584   4                      if(CleanCount >= 5)
 585   4                          CtrlPara.step = 4;//Â§ß‰∫é50msËøõÂÖ•Ê≠•È™§4
 586   4                      else
 587   4                          CtrlPara.step = 2;//ÂõûÂà∞Ê≠•È™§2
 588   4                  }
 589   3              }
 590   2              break;
 591   2              case 4:
 592   2              DeviceStatus = status_Idle;//ÂõûÂà∞Áä∂ÊÄÅ
 593   2              CtrlPara.execute = 0;
 594   2              CtrlPara.quit    = 0;
 595   2              CtrlPara.step    = 0;
 596   2              break;
 597   2          }
 598   1      }
 599          
 600          void PipelineFlushing(LogicParaDef*p)//ÂÜ≤Ê¥óÁÆ°ÈÅì
 601          {
 602   1          TASK_QUIT
 603   1          {
 604   2              if(FlashUartByte(CMD_SteamPump|CMD_DirOutput|CMD_FlowCtrl))
 605   2              {
 606   3                  DirectOutput.OutputCtrlBit.CoffeValve= DirOutPut_OFF;
 607   3                  FlowCtrl.FlowCtrlByte = Flow_End;
 608   3                  PumpCtrl.workFlag = OFF;
 609   3                  CtrlPara.execute = 0;
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 11  

 610   3                  CtrlPara.quit    = 0;
 611   3                  CtrlPara.step    = 0;
 612   3              }
 613   2          }
 614   1          TASK_PROCESS
 615   1          {
 616   2              case 1:
 617   2              Dis_Temperature(0,NoUnitDis);
 618   2              if(FlashUartByte(CMD_SteamPump|CMD_FlowCtrl|CMD_DirOutput))
 619   2              {
 620   3                  DirectOutput.OutputCtrlBit.CoffeValve= DirOutPut_ON;//ÂºÄÂíñÂï°ÁîµÁ£ÅÈòÄ
 621   3                  FlowCtrl.FlowCtrlByte = Flow_Scan;
 622   3                  PumpCtrl.Duty   = 100;
 623   3                  PumpCtrl.Period = 100;
 624   3                  PumpCtrl.workFlag = ON;
 625   3                  TimerRes(&Tim);
 626   3                  CtrlPara.step = 2;
 627   3              }
 628   2              break;
 629   2              case 2:
 630   2              EndDis=GetTime(Tim,DIV_1S);
 631   2              Dis_Temperature(EndDis,NoUnitDis);
 632   2              if(EndDis>= 15)//15s
 633   2              {
 634   3                  if(FlashUartByte(CMD_SteamPump|CMD_FlowCtrl|CMD_DirOutput))//ÂÖ≥Èó≠ÂíñÂï°ÁîµÁ£ÅÈòÄ
 635   3                  {
 636   4                      DirectOutput.OutputCtrlBit.CoffeValve= DirOutPut_OFF;
 637   4                      FlowCtrl.FlowCtrlByte = Flow_End;
 638   4                      PumpCtrl.workFlag = OFF;
 639   4                      CtrlPara.step = 3;
 640   4                  }
 641   3              }
 642   2              break;
 643   2              case 3:
 644   2                  DeviceStatus = status_Idle;//ÂõûÂà∞ÊòæÁ§∫Áä∂ÊÄÅ
 645   2                  CtrlPara.execute = 0;
 646   2                  CtrlPara.quit    = 0;
 647   2                  CtrlPara.step    = 0;
 648   2              break;
 649   2          }
 650   1      }
 651          
 652          
 653          
 654          
 655          #define TimeOut 200
 656          void OutPutFlash()   
 657          {
 658   1          static u8 DelayCnt1 =0;
 659   1          static u8 DelayCnt2 =0;
 660   1          static u8 DelayCnt3 =0;
 661   1          static u8 DelayCnt4 =0;
 662   1          static u8 DelayCnt5 =0;
 663   1          static u8 DelayCnt6 =0;
 664   1          static u8 DelayCnt7 =0;
 665   1          if(UartFlag&CMD_ADSensor)
 666   1          {
 667   2              DelayCnt1--;
 668   2              if(DelayCnt1==0)
 669   2              {
 670   3                  DelayCnt1=TimeOut;
 671   3                  DataFrameTransmission(&AdPara,CMD_ADSensor,sizeof(AdParaTypedef));
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 12  

 672   3              }
 673   2          }
 674   1          else
 675   1              DelayCnt1=0;
 676   1          if(UartFlag&CMD_FlowCtrl)
 677   1          {
 678   2              DelayCnt2--;
 679   2              if(DelayCnt2==0)
 680   2              {
 681   3                  DelayCnt2=TimeOut;
 682   3                  DataFrameTransmission(&FlowCtrl,CMD_FlowCtrl,sizeof(FlowCtrlTypedef));  
 683   3              }
 684   2          }
 685   1          else
 686   1              DelayCnt2=0;
 687   1          if(UartFlag&CMD_DirOutput)
 688   1          {
 689   2              DelayCnt3--;
 690   2              if(DelayCnt3==0)
 691   2              {
 692   3                  DelayCnt3=TimeOut;
 693   3                  DataFrameTransmission(&DirectOutput,CMD_DirOutput,sizeof(DirectOutputType));
 694   3              }
 695   2          }
 696   1          else
 697   1              DelayCnt3=0;
 698   1          if(UartFlag&CMD_SteamPump)
 699   1          {
 700   2              DelayCnt4--;
 701   2              if(DelayCnt4==0)
 702   2              {
 703   3                  DelayCnt4=TimeOut;
 704   3                  DataFrameTransmission(&PumpCtrl,CMD_SteamPump,sizeof(DutyCycleOutputType));
 705   3              }
 706   2          }
 707   1          else
 708   1              DelayCnt4=0;
 709   1          if(UartFlag&CMD_SteamHeat)
 710   1          {
 711   2              DelayCnt5--;
 712   2              if(DelayCnt5==0)
 713   2              {
 714   3                  DelayCnt5=TimeOut;
 715   3                  DataFrameTransmission(&PotHeatCtrl,CMD_SteamHeat,sizeof(DutyCycleOutputType));
 716   3              }
 717   2          }
 718   1          else
 719   1              DelayCnt5=0;
 720   1          if(UartFlag&CMD_LampCtrl)
 721   1          {
 722   2              DelayCnt6--;
 723   2              if(DelayCnt6==0)
 724   2              {
 725   3                  DelayCnt6=TimeOut;
 726   3                  DataFrameTransmission(&LampCtrl,CMD_LampCtrl,sizeof(LampCtrlTypedef));
 727   3              }
 728   2          }
 729   1          else
 730   1              DelayCnt6=0;
 731   1          if(UartFlag&CMD_Flow)
 732   1          {
 733   2              DelayCnt7--;
C51 COMPILER V9.54   LOGIC                                                                 07/12/2025 08:10:59 PAGE 13  

 734   2              if(DelayCnt7==0)
 735   2              {
 736   3                  DelayCnt7=TimeOut;
 737   3                  DataFrameTransmission(&CurFlow,CMD_Flow,sizeof(CurFlow));
 738   3              }
 739   2          }
 740   1          else
 741   1              DelayCnt7=0;
 742   1      }
 743          
 744          void Logic()
 745          {
 746   1          ProgramInit(&LT.InitTask);//ÂàùÂßãÂåñ‰ªªÂä°//Êé•ÈÄöÁîµÊ∫êÔºåÊú∫Âô®ÈïøÂìç‰∏ÄÂ£∞(Êª¥1s)ÔºåÊâÄÊúâÁÅØÂèäÊò
             -æÁ§∫ÂÖ®‰∫Æ1sÂêéÁÜÑÁÅ≠Ôºõ‰ªÖ‚ÄúÁîµÊ∫ê‚ÄùÊåâÈîÆÁÅØÈó™ÁÉÅÔºàÈó¥Èöî1s/Èó™Ôºâ„ÄÇ
 747   1          Makecoffe(&LT.MakeCoffeTask);
 748   1          MakeSteam(&LT.MakeSteamTask);
 749   1          MakeHotWater(&LT.MakeHotWaterTask);
 750   1          Grind(&LT.GrindBeanTask);
 751   1          PotHeat(&LT.PotHeatTask);
 752   1          Clean(&LT.CleanTask);
 753   1          PipelineFlushing(&LT.PipelineFlushingTask);
 754   1        OutPutFlash();
 755   1      }
 756          
 757          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3275    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     40    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
